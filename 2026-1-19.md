# VProfile Project: Building a Multi-Tier Web Stack Locally

*A note to my future self: Today I started a big project - deploying a multi-tier web application stack using 5 VMs on my local machine. This is about understanding how production-grade architectures work. Here's what I learned.*

## The Big Picture

I'm setting up a complete web application stack with 5 different services running on 5 separate VMs. The goal is to make this automated and repeatable using Vagrant, so I can destroy and recreate the entire environment whenever I need to.

**The Stack:**
- **VMware Desktop** as the hypervisor (on my Mac M1)
- **Vagrant** for automation
- **5 VMs** running different services

## Understanding the Service Flow

One of the most important things I learned today is **why the services are set up in this specific order**. The flow follows how data moves through the application:

```
User Request
    â†“
1. NGINX (web01) - Front door, handles requests
    â†“
2. Tomcat (app01) - Runs the Java application
    â†“
3. RabbitMQ (rmq01) - Queues background tasks
    â†“
4. Memcached (mc01) - Checks cache first
    â†“
5. MySQL/MariaDB (db01) - Database (if cache miss)
```

**Why this order?** Because that's the actual flow of data! Understanding this helps with troubleshooting and knowing which service to set up first (you build from the database up).

## The Five Services Explained

Today I learned what each service does and *why* it exists in the stack:

### NGINX - The Front Door
- **What it is:** Web server and reverse proxy
- **Why we need it:** Sits in front of everything, handles incoming traffic efficiently
- **Real-world use:** Static files, SSL termination, load balancing
- **Cool fact:** Uses event-driven architecture, can handle 10,000+ connections with minimal memory!

### Apache Tomcat - The Java Engine  
- **What it is:** Application server for Java web apps
- **Why we need it:** Runs our Java application (Servlets/JSPs)
- **Real-world use:** Hosts the actual business logic
- **Key insight:** Usually paired with NGINX in production (NGINX handles static content, Tomcat handles dynamic Java processing)

### RabbitMQ - The Message Broker
This one was new to me! It's basically a "post office" for services.

**The problem it solves:**
- Without RabbitMQ: Service A calls Service B directly â†’ If B is down, everything breaks
- With RabbitMQ: Service A sends message to queue â†’ Service B processes when ready

**Real-world example:** When a user places an order:
1. User gets immediate response (order placed!)
2. RabbitMQ queues background tasks:
   - Process payment
   - Update inventory  
   - Send email
   - Notify shipping

**Why this matters:** Services don't need to wait for each other. Traffic spikes won't crash the system because requests get queued.

### Memcached - The Speed Layer
**Mind-blowing stat:** Reading from RAM (Memcached) = 1ms. Reading from database = 100ms. That's **100x faster!**

**How it works:**
- App checks Memcached first
- If data exists (cache hit) â†’ Return instantly âœ…
- If not (cache miss) â†’ Query database â†’ Store in cache for next time

**Real-world impact:** 
- Without cache: 10,000 users viewing a profile = 10,000 database queries ðŸ’¥
- With cache: First user hits DB, next 9,999 get cached data (< 1ms each) âœ¨

### MySQL/MariaDB - The Data Store
**Discovery:** MariaDB is a fork of MySQL - same commands, same syntax, compatible!

Today I set this one up. Learned the command to import database:
```bash
mysql -u root -padmin123 accounts < db_backup.sql
```

**What this does:** Logs into MySQL and runs all SQL commands from the file to create tables and insert data.

## Repository Concept - Finally Makes Sense!

I struggled with `dnf update` taking forever (20+ minutes!), which led me to learn about repositories.

**The restaurant analogy that clicked:**
- Repository = Restaurant with a menu
- Package = A dish from the menu
- DNF = Your delivery driver
- Metadata = The menu itself

**Why `dnf update` is slow:**
1. Has to check multiple "restaurant menus" (repos)
2. Fresh VM = lots of outdated packages
3. ARM architecture = fewer mirrors (delivery drivers are far away!)
4. Default 512MB RAM = system struggling

**EPEL explained:**
- `epel-release` is NOT the repository
- It's the **package that gives you access** to the EPEL repository
- Like getting a membership card to Costco!

**Before installing epel-release:**
```bash
Available repos: BaseOS, AppStream, Extras
```

**After:**
```bash
Available repos: BaseOS, AppStream, Extras, EPEL â† NEW!
```

Now you can install packages that weren't available before (like htop, ncdu, etc.)

## What I Actually Did Today

### Infrastructure Setup
- Created Vagrantfile with 5 VM definitions
- Used `vagrant-hostmanager` plugin (automatic hostname resolution!)
- Set up private network: 192.168.56.21-25

### Database Setup (db01)
Successfully installed and configured MariaDB:
- Created `accounts` database
- Imported schema from backup file
- Practiced connecting: `mysql -u root -padmin123 accounts`
- Learned SQL basics: `SHOW DATABASES`, `USE accounts`, `SHOW TABLES`

### The Memory Problem I Discovered

**VMware Desktop default memory: 512 MB** - way too low!

My current allocation:
- db01: 600 MB âš ï¸ (still low for MySQL)
- mc01: 512 MB (default) âš ï¸
- rmq01: 512 MB (default) âš ï¸
- app01: 1024 MB âœ…
- web01: 512 MB (default) âš ï¸

**What I should do:** Increase all to at least 1GB, preferably 2GB for database and app server.

## Mistakes I Made (And What I Learned)

### Mistake 1: Running Bash Commands in MySQL
```sql
mysql> mysql -u root -p
ERROR: You have an error in your SQL syntax...
```

**The lesson:** Always know which prompt you're in!
- `$` = Bash terminal â†’ Shell commands work
- `mysql>` = MySQL prompt â†’ SQL commands work

Can't mix them! Need to `exit` MySQL first before running bash commands.

### Mistake 2: Not Understanding Input Redirection
```bash
mysql -u root -padmin123 accounts < db_backup.sql
```

**What the `<` does:** Feeds the file contents into the mysql command (like reading from a script).

This is **not** a MySQL command - it's a bash feature!

## Key Insights That Clicked

### 1. Cache Strategy
"Check cache â†’ then database" is a pattern I'll see everywhere. It's not just about speed, it's about **reducing load on the expensive resource** (the database).

### 2. Async Processing
RabbitMQ enables "fire and forget" - user gets response immediately, heavy work happens in background. This is how modern scalable systems work!

### 3. Service Decoupling
Each service in the stack can fail/restart independently. RabbitMQ messages wait in queue. Cached data remains available. The architecture is **resilient by design**.

### 4. Repository Safety
Using repositories isn't just convenient - it's **safe**:
- Packages are cryptographically signed
- Come from trusted sources
- Dependencies automatically resolved
- No sketchy downloads from random websites!

## The "Aha!" Moment

The biggest realization: **This isn't just 5 random services.** Each one serves a specific architectural need:

- **Performance:** Memcached, NGINX
- **Scalability:** RabbitMQ, Tomcat
- **Reliability:** Decoupled services
- **User Experience:** Fast responses (async + cache)

This is a **production-grade architecture pattern** used by companies like Netflix, Airbnb, Twitter. Understanding why each piece exists is more important than just knowing how to install them.

## What's Next

Tomorrow I'll continue with:
1. Update Vagrantfile with proper memory allocations
2. Set up Memcached (mc01)
3. Configure RabbitMQ (rmq01)
4. Eventually connect everything together

## Resources to Remember

- Vagrant boxes for ARM: `bandit145/centos_stream9_arm`, `spox/ubuntu-arm`
- Speed up DNF: `max_parallel_downloads=10` in `/etc/dnf/dnf.conf`
- MySQL import: `mysql -u root -p dbname < file.sql`
- Exit MySQL: `exit` or `quit` or `Ctrl+D`

---

*Future me: This project is teaching me production architecture patterns. Don't rush through the setups - understand why each service exists and how they work together. The "why" is more valuable than the "how"!*
