## Building a Multi‑VM Lab & Getting Comfortable with Vagrant, Linux Services, and Databases

*Note to future me: today was about going beyond a single VM and really wiring pieces together – web servers, a DB server, networking, and tooling around them. Here’s what I actually did and what I learned along the way so I don’t have to rediscover it later.*

---

### **1. Designing and Bootstrapping a Multi‑VM Vagrant Lab**

- **What I set up**
  - Created a new directory: `multi-vm-lab` under `devops/vms/`.
  - Wrote a **single Vagrantfile** defining three VMs:
    - **`web01`** – Ubuntu (hashicorp/bionic64), `hostname "web01.local"`, private IP `192.168.56.11`
    - **`web02`** – Ubuntu (hashicorp/bionic64), `hostname "web02.local"`, private IP `192.168.56.12`
    - **`db01`** – CentOS Stream 9 (bandit145/centos_stream9_arm as a stand‑in for CentOS 7 on ARM), `hostname "db01.local"`, private IP `192.168.56.21`
  - Configured the **provider block** for VMware on my M‑series Mac:
    - `vmware_desktop` provider with `memory "1024"`, `cpus 2`, `gui true`, `allowlist_verified true`.
- **Key Vagrant patterns I reinforced**
  - `config.vm.define "name" do |node| ... end` lets me describe multiple machines in one Vagrantfile.
  - `node.vm.box`, `node.vm.hostname`, and `node.vm.network "private_network", ip: "X.Y.Z.W"` are the core pieces to get a named VM with a stable private IP.
  - Private networks are perfect for lab setups: accessible from my host, isolated from the rest of the world, and predictable IPs for hard‑coded configs (e.g., DB connection strings).

---

### **2. Provisioning a Dedicated Database Server (db01)**

- **External shell provisioner**
  - Instead of stuffing everything into the Vagrantfile, I created a separate script: `db_provision.sh`.
  - Hooked it up with:
    ```ruby
    db.vm.provision "shell", path: "db_provision.sh"
    ```
  - Marked it executable with:
    ```bash
    chmod +x db_provision.sh
    ```
  - This keeps the Vagrantfile clean and makes it easy to iterate on provisioning logic.

- **What `db_provision.sh` does**
  - (Optionally) update packages (`yum -y update` – I commented it out for speed when iterating).
  - Install and start **MariaDB server**:
    ```bash
    yum -y install mariadb-server
    systemctl enable mariadb
    systemctl start mariadb
    ```
  - Perform a **basic non‑interactive hardening**:
    - Remove anonymous users.
    - Restrict root to localhost.
    - Drop the `test` database.
    - `FLUSH PRIVILEGES;` to apply changes.
  - Create an **application database and user**:
    ```sql
    CREATE DATABASE IF NOT EXISTS appdb
      CHARACTER SET utf8mb4
      COLLATE utf8mb4_unicode_ci;
    CREATE USER IF NOT EXISTS 'appuser'@'%' IDENTIFIED BY 'app_password123';
    GRANT ALL PRIVILEGES ON appdb.* TO 'appuser'@'%';
    FLUSH PRIVILEGES;
    ```
  - Lesson: MariaDB uses the same SQL as MySQL for user and DB management, but on RHEL/CentOS you install it via `yum install mariadb-server` instead of `apt install mysql-server`.

- **Hostnames & `/etc/hosts`**
  - Setting `vm.hostname` in Vagrant automatically configures `/etc/hostname` and usually updates `/etc/hosts` inside the guest, which makes prompts and logs much clearer (`[web01]` vs `localhost`).

---

### **3. Vagrant Lifecycle & Global Management**

- **Managing multiple VMs at once**
  - Brought the whole lab up with:
    ```bash
    vagrant up
    ```
  - Checked status of all VMs:
    ```bash
    vagrant status
    ```
  - Targeted SSH into specific nodes:
    ```bash
    vagrant ssh web01
    vagrant ssh web02
    vagrant ssh db01
    ```

- **Destroying everything cleanly**
  - Learned about `vagrant global-status` to list *all* VMs Vagrant knows about:
    ```bash
    vagrant global-status
    ```
  - To clean up every running or powered‑off VM without manually cd‑ing into each directory:
    ```bash
    vagrant global-status --prune | awk '/running|poweroff/ {print $1}' | xargs -r vagrant destroy -f
    ```
  - What this pipeline does:
    - `vagrant global-status --prune` → list all known VMs and drop stale entries.
    - `awk '/running|poweroff/ {print $1}'` → filter lines where state is `running` or `poweroff`, print the first column (the VM ID).
    - `xargs -r vagrant destroy -f` → run `vagrant destroy -f <id>` for each ID, skipping if there’s nothing to process.

---

### **4. Getting Comfortable with `awk`**

- **What `awk` is**
  - A powerful text-processing language, named after its authors: **A**ho, **W**einberger, **K**ernighan.
  - It reads input line by line, splits each line into fields (by default, whitespace), and lets me run simple scripts like “if this pattern matches, print these columns.”

- **Understanding today’s `awk` usage**
  - From the `vagrant global-status` pipeline:
    ```bash
    awk '/running|poweroff/ {print $1}'
    ```
  - `/running|poweroff/` — pattern: match any line that contains either `running` or `poweroff`.
  - `{print $1}` — action: print the first field (the VM ID) from those matching lines.

- **Quick mental model / examples**
  - Print first column of a file:
    ```bash
    awk '{print $1}' somefile
    ```
  - Print lines that contain a word:
    ```bash
    awk '/error/ { print }' logfile
    ```
  - Filter by column value:
    ```bash
    awk '$2 == "running" { print $1, $2 }'
    ```
  - Key idea: **pattern { action }**, where `pattern` decides which lines to act on, and `action` decides what to do with them.

---

### **5. Reinforcing Vagrant & OS Differences**

- **Ubuntu vs CentOS boxes**
  - Ubuntu VMs (web01/web02) used `hashicorp/bionic64` – these use `apt` as the package manager.
  - The DB VM is CentOS‑based (`bandit145/centos_stream9_arm`):
    - Uses `yum` instead of `apt`.
    - Uses **`firewalld`** instead of `ufw`.
    - Uses **`mariadb-server`** instead of `mysql-server`.

- **Hostnames & networking**
  - Learned to set `vm.hostname` and `vm.network "private_network", ip: ...` for each VM.
  - This makes it easy to SSH and reason about the environment (`web01` talking to `db01` on `192.168.56.21`).

---

### 6. Small but Useful Patterns I Don’t Want to Forget

- **Creating new Vagrant labs**
  - Pattern:
    ```bash
    mkdir -p <lab-name>
    cd <lab-name>
    # then create Vagrantfile with multiple config.vm.define blocks
    ```
  - I don’t have to run `vagrant init` every time; I can just drop in a hand‑crafted Vagrantfile.

- **Commenting out slow steps while iterating**
  - For faster feedback when tweaking provisioning, I commented out slow steps like:
    ```bash
    # yum -y update
    ```
  - Once the provisioning logic is stable, I can re‑enable full updates for a “real” environment.

---

### Wrap‑Up: The Big Picture

Today was about moving from “I can start a VM” to “I can design a small infrastructure topology and manage it with confidence.” I now know how to:

- Describe **multiple machines** in one Vagrantfile with distinct OSes, hostnames, and private IPs.
- Use **external provisioner scripts** to keep Vagrantfiles clean and to encapsulate server roles (like `db01` as a dedicated DB server).
- Manage VMs at scale with `vagrant global-status`, `vagrant destroy`, and `awk` + `xargs` to automate cleanup.
- Reason about the differences between **Ubuntu and CentOS** environments (apt vs yum, ufw vs firewalld, MySQL vs MariaDB).

Next time I need a quick lab with several servers talking to each other, I won’t hesitate to spin up a multi‑VM Vagrant environment and wire it together with a couple of focused provision scripts. This session moved Vagrant from “tool I kind of know” to “something I can actually shape into what I need.”\n
