# How I Setup WordPress on CentOS: The Challenges I Faced and How I Overcame Them

*A note to my future self: This was a journey of troubleshooting, learning, and persistence. Here's everything I learned so you don't have to struggle through it again.*

## The Goal

I wanted to set up a fresh WordPress installation on CentOS Stream 9 using Vagrant. Simple enough, right? Well, it turned into a masterclass in Linux system administration, Apache configuration, and debugging. Here's what happened.

## The Setup

I created a new Vagrant VM using the `bandit145/centos_stream9_arm` box with a private network IP of `192.168.67.10`. I decided to do everything manually, step by step, rather than using provisioning scripts. This was a great learning decision, even though it took longer.

## Challenge 1: The Apt Lock Issue (Wait, This is CentOS!)

**What happened:** I initially tried to install packages but got an error about `apt` lock being held by `unattended-upgrades`. 

**What I learned:** 
- CentOS uses `yum` (or `dnf`), not `apt` (that's for Debian/Ubuntu)
- The error was actually from a different VM I was working on (Ubuntu)
- Always know which distribution you're working with!

**How I overcame it:** I realized I was mixing up VMs. For CentOS, I used `yum install` instead.

## Challenge 2: Installing Apache (httpd)

**What I did:**
```bash
sudo yum install -y httpd
sudo systemctl start httpd
sudo systemctl enable httpd
```

**What I learned:**
- On CentOS, Apache is called `httpd`, not `apache2` (that's Ubuntu again!)
- `systemctl start` starts the service immediately
- `systemctl enable` makes it start automatically on boot
- Always check service status: `sudo systemctl status httpd`

**The result:** Apache was running, but I could only see the default CentOS test page.

## Challenge 3: Configuring the Firewall

**What I did:**
```bash
sudo firewall-cmd --permanent --add-service=http
sudo firewall-cmd --permanent --add-service=https
sudo firewall-cmd --reload
sudo firewall-cmd --list-all
```

**What I learned:**
- CentOS uses `firewalld`, not `ufw` (that's Ubuntu's firewall)
- `--permanent` makes the rule persist across reboots
- `--reload` applies the permanent rules without restarting the service
- Always verify with `--list-all` to see what's actually configured

**The result:** HTTP traffic was now allowed through the firewall.

## Challenge 4: Installing PHP and Extensions

**What I did:**
```bash
sudo yum install -y php php-cli php-fpm php-mysqlnd php-xml php-curl php-zip php-gd php-mbstring php-json
php -v
```

**What I learned:**
- WordPress needs specific PHP extensions: `php-mysqlnd` (for database), `php-xml`, `php-curl`, `php-zip`, `php-gd`, `php-mbstring`
- `php-mysqlnd` is the correct package name on CentOS (not `php-mysql`)
- Always verify PHP is working with `php -v` and test with a simple `phpinfo()` file

**The result:** PHP was installed with all necessary extensions.

## Challenge 5: Installing and Securing MariaDB

**What I did:**
```bash
sudo yum install -y mariadb-server mariadb
sudo systemctl start mariadb
sudo systemctl enable mariadb
sudo mysql_secure_installation
```

**What I learned:**
- CentOS uses MariaDB (MySQL-compatible) by default
- `mysql_secure_installation` is crucial for setting root password and removing test databases
- Always set a strong root password during the security setup

**Creating the WordPress database:**
```sql
CREATE DATABASE wordpress CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
CREATE USER 'wpuser'@'localhost' IDENTIFIED BY 'your_password';
GRANT ALL PRIVILEGES ON wordpress.* TO 'wpuser'@'localhost';
FLUSH PRIVILEGES;
```

**What I learned:**
- Use `utf8mb4` character set for WordPress (supports emojis and full Unicode)
- Create a dedicated user for WordPress (don't use root!)
- `FLUSH PRIVILEGES` is required after granting privileges
- Always verify with `SHOW DATABASES;` and `SELECT User, Host FROM mysql.user;`

## Challenge 6: Downloading and Installing WordPress

**What I did:**
```bash
cd /tmp
curl -O https://wordpress.org/latest.tar.gz
tar xzf latest.tar.gz
sudo cp -r wordpress/* /var/www/html/
```

**What I learned:**
- Always download to `/tmp` first, then move files
- WordPress extracts into a `wordpress/` subdirectory
- Need to copy contents, not the directory itself
- Remove the default `index.html` test page!

**The result:** WordPress files were in place, but I still saw the CentOS test page.

## Challenge 7: The Persistent Test Page Problem

**What happened:** Even after copying WordPress files, I kept seeing the CentOS test page in my browser.

**What I learned:**
- Apache serves `index.html` before `index.php` by default
- The `DirectoryIndex` directive controls which files are served first
- Need to check: `grep -i "DirectoryIndex" /etc/httpd/conf/httpd.conf`

**How I overcame it:**
1. Removed the default test page: `sudo rm /var/www/html/index.html`
2. Updated Apache config to prefer PHP:
   ```
   DirectoryIndex index.php index.html
   ```
3. Restarted Apache: `sudo systemctl restart httpd`

**The result:** Still seeing the test page! (More on this later...)

## Challenge 8: Understanding File Permissions (The 403 Forbidden Error)

**What happened:** After fixing DirectoryIndex, I got a 403 Forbidden error when trying to access WordPress.

**What I learned about Linux permissions:**
- **Ownership matters:** Apache runs as the `apache` user (or `httpd` on some systems)
- **Permission numbers:**
  - `755` for directories = owner: read+write+execute, others: read+execute
  - `644` for files = owner: read+write, others: read only
- **The commands:**
  ```bash
  sudo chown -R apache:apache /var/www/html
  sudo find /var/www/html -type d -exec chmod 755 {} \;
  sudo find /var/www/html -type f -exec chmod 644 {} \;
  ```

**What each part means:**
- `chown -R apache:apache` = change owner recursively to apache user and group
- `find -type d` = find all directories
- `find -type f` = find all files
- `-exec chmod 755 {} \;` = execute chmod on each found item

**How I overcame it:**
1. Fixed ownership: `sudo chown -R apache:apache /var/www/html`
2. Set directory permissions: `sudo find /var/www/html -type d -exec chmod 755 {} \;`
3. Set file permissions: `sudo find /var/www/html -type f -exec chmod 644 {} \;`
4. Restarted Apache: `sudo systemctl restart httpd`

**The result:** 403 error resolved! But then I hit the database connection issue.

## Challenge 9: SELinux - The Silent Blocker

**What I learned:**
- SELinux can block Apache from accessing files or connecting to databases
- Check status: `getenforce` (returns Enforcing, Permissive, or Disabled)
- Key commands for WordPress:
  ```bash
  sudo chcon -R -t httpd_sys_content_t /var/www/html/
  sudo setsebool -P httpd_can_network_connect 1
  sudo setsebool -P httpd_can_network_connect_db 1
  ```

**What each does:**
- `chcon` = change SELinux context (tells SELinux these are web files)
- `setsebool httpd_can_network_connect` = allow Apache to make network connections
- `setsebool httpd_can_network_connect_db` = allow Apache to connect to databases
- `-P` = make the setting permanent

## Challenge 10: Database Connection Error

**What happened:** WordPress loaded but showed "Error establishing a database connection."

**What I learned:**
- Always verify MariaDB is running: `sudo systemctl status mariadb`
- Check database exists: `SHOW DATABASES;`
- Check user exists: `SELECT User, Host FROM mysql.user WHERE User = 'wpuser';`
- Verify credentials in `wp-config.php` match what you created

**How I overcame it:**
1. Verified MariaDB was running
2. Created database and user (if they didn't exist)
3. Updated `wp-config.php`:
   ```bash
   sudo sed -i "s/database_name_here/wordpress/" /var/www/html/wp-config.php
   sudo sed -i "s/username_here/wpuser/" /var/www/html/wp-config.php
   sudo sed -i "s/password_here/your_password/" /var/www/html/wp-config.php
   ```
4. Allowed Apache to connect to database: `sudo setsebool -P httpd_can_network_connect_db 1`

## Key Takeaways for Future Me

1. **Know your distribution:** CentOS ≠ Ubuntu. Commands differ (`yum` vs `apt`, `httpd` vs `apache2`, `firewalld` vs `ufw`)

2. **File permissions are critical:** 
   - Ownership must match the web server user
   - Directories need execute permission (755)
   - Files need read permission (644)

3. **SELinux can silently block things:** Always check if SELinux is enforcing and configure it properly

4. **Apache configuration matters:**
   - `DirectoryIndex` controls which file is served first
   - `AllowOverride All` is needed for WordPress `.htaccess` files
   - Always restart Apache after config changes

5. **Database setup:**
   - Use `utf8mb4` character set
   - Create dedicated database users (never use root)
   - Test connections before assuming they work

6. **Debugging methodology:**
   - Check service status first: `systemctl status <service>`
   - Check logs: `/var/log/httpd/error_log`, `/var/log/mariadb/mariadb.log`
   - Test from inside the VM: `curl http://localhost`
   - Verify permissions: `ls -la /var/www/html`

7. **Vim tips I learned:**
   - Search: `/pattern` (forward), `?pattern` (backward)
   - Next match: `n`, Previous: `N`
   - Clear search highlight: `:noh`

## The Final Working Setup

After all these challenges, here's what worked:

1. ✅ Apache (httpd) installed and running
2. ✅ Firewall configured to allow HTTP
3. ✅ PHP installed with all WordPress extensions
4. ✅ MariaDB installed, secured, and database created
5. ✅ WordPress downloaded and files in place
6. ✅ File permissions set correctly
7. ✅ SELinux configured to allow web operations
8. ✅ Database connection working
9. ✅ WordPress installation screen appearing!

## What I'd Do Differently Next Time

1. **Use provisioning script** - Now that I understand each step, automating it would save time
2. **Document passwords** - Keep track of database passwords in a secure way
3. **Test incrementally** - After each major step, test before moving to the next
4. **Check logs first** - When something breaks, check logs before guessing

## Resources That Helped

- Apache error logs: `/var/log/httpd/error_log`
- MariaDB logs: `/var/log/mariadb/mariadb.log` or `journalctl -u mariadb`
- Service status: `systemctl status <service>`
- File permissions: `ls -la` to see ownership and permissions
- SELinux: `getenforce` and `setsebool` commands

---

*Future me: This was a great learning experience. You now understand how web servers, databases, and Linux permissions work together. Use this knowledge well!*

